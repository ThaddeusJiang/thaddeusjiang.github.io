created: 20210127141137768
creator: TJ
history: 2025-09-18
modified: 20251114013639423
modifier: TJ
tags: #repeated tj-edu
title: boilerplate code
type: text/vnd.tiddlywiki

boilerplate code，即和业务无关，为了使用某种技术或者设计而不得不反复重复的代码。

典型的 boilerplate code

# Java DTO
# UI: isLoading, isError, setState

!! 2025-09-18 

我太想让所有和我合作的开发者都能理解 boilerplate code is bad 的思想了。

我发现的新的 UI boilerplate code 就是 shadcn/ui , base-ui

```jsx
import * as React from 'react';
import { Dialog } from '@base-ui-components/react/dialog';
import styles from './index.module.css';

export default function ExampleDialog() {
  return (
    <Dialog.Root>
      <Dialog.Trigger className={styles.Button}>View notifications</Dialog.Trigger>
      <Dialog.Portal>
        <Dialog.Backdrop className={styles.Backdrop} />
        <Dialog.Popup className={styles.Popup}>
          <Dialog.Title className={styles.Title}>Notifications</Dialog.Title>
          <Dialog.Description className={styles.Description}>
            You are all caught up. Good job!
          </Dialog.Description>
          <div className={styles.Actions}>
            <Dialog.Close className={styles.Button}>Close</Dialog.Close>
          </div>
        </Dialog.Popup>
      </Dialog.Portal>
    </Dialog.Root>
  );
}
```

合理的方式：我推荐使用 daisyUI

```html
{/* Open the modal using document.getElementById('ID').showModal() method */}
<button className="btn" onClick={()=>document.getElementById('my_modal_1').showModal()}>open modal</button>

<dialog id="my_modal_1" className="modal">
  <div className="modal-box">
    <h3 className="font-bold text-lg">Hello!</h3>
    <p className="py-4">Press ESC key or click the button below to close</p>
    <div className="modal-action">
      <form method="dialog">
        {/* if there is a button in form, it will close the modal */}
        <button className="btn">Close</button>
      </form>
    </div>
  </div>
</dialog>
```


!! 2020-05-19 

终于理解了 Svelte 宣扬的第一条特性 “Build boilerplate-free components” 是什么意思。

React 的数据更新太麻烦了。

```js
const [name, setName] = useState('')
const [age, setAge] = useState(0)
const [address, setAddress] = useState('')

return (
  <div>
    <input value={name} onChange={(e) => setName(e.target.value)}>
    <input value={age} onChange={(e) => setAge(e.target.value)}>
    <input value={address} onChange={(e) => setAddress(e.target.value)}>
  </div>
)
```

其实 setName 和 onChange 等函数完全和业务无关，单纯是为了 React 语法而已。

Svelte 提供 binding 语法，超级简单。

```js
<script>
let name = ''
let age = 0
let address = ''
</script>

<input value={name}>
<input type=number value={age}>
<input value={address}>
```

那种编写方法更容易？一目了然

! 类比：

* 读取文件也是 boilerplate，你必须确认 file 存在，读取完毕后还必须关闭 file。
* RESTful API 也是 boilerplate，CURD 写到吐。难怪 Ruby on Rails 会那么人气。开发者救星啊！！！

refs:

* https://svelte.dev/
